diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 722196c..d0da175 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -22,7 +22,7 @@ set(client_srcs  client/client.cpp)
 
 link_libraries("-fPIC -Wl,-Bdynamic")
 link_libraries(pthread)
-link_libraries(sqlite3)
+#link_libraries(sqlite3)
 
 # Server binary
 add_executable(server ${server_srcs})
diff --git a/src/client/client.cpp b/src/client/client.cpp
index f0ccc3a..1fa092e 100644
--- a/src/client/client.cpp
+++ b/src/client/client.cpp
@@ -9,6 +9,8 @@
 #include <condition_variable>
 #include <cstring>
 
+#include <arpa/inet.h>
+
 #include "client.h"
 
 /*
@@ -60,27 +62,29 @@ status_e Client::SetupSocket()
 {
     DEBUG_PRINT_LN("");
 
-    if ((client_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == 0)
+    if ((client_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0)
     {
         ERROR_PRINT_LN("Seeder server socket creation failed");
         return status_error;
     }
 
-    int opt = 1;
-    if (setsockopt(client_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,
-            &opt, sizeof(opt)) != 0)
-    {
-        ERROR_PRINT_LN("Setsockopt error");
-        return status_error;
-    }
-
     // Filling server information
     server_address.sin_family = AF_INET;
     server_address.sin_port = htons(seeder_server_default_port);
-    server_address.sin_addr.s_addr = htonl(INADDR_ANY);
 
+    if (inet_pton(AF_INET, "127.0.0.1", &server_address.sin_addr) <= 0)
+    {
+        ERROR_PRINT_LN("Invalid address/ Address not supported");
+        return status_error;
+    }
     server_address_len = sizeof(server_address);
 
+    if (connect(client_socket, (struct sockaddr *)&server_address, sizeof(server_address)) < 0)
+    {
+        ERROR_PRINT_LN("Connect error");
+        return status_error;
+    }
+
     socket_thread.reset(new std::thread(&Client::SocketFunction, this));
 
     DEBUG_PRINT_LN("completed");
@@ -140,18 +144,18 @@ status_e Client::ProcessInput()
 
         if (input == "1")
         {
-            if (sendto(client_socket, (void *)hello_msg.data(), hello_msg.size(),
-                    MSG_WAITALL, (struct sockaddr *) &server_address, server_address_len) != 0)
+            if (send(client_socket, (void *)hello_msg.data(), hello_msg.size(),
+                    0) != 0)
             {
-                ERROR_PRINT_LN("Sendto returned error: ", strerror(errno), "(", errno, ")");
+                ERROR_PRINT_LN("Send returned error: ", strerror(errno), "(", errno, ")");
             }
         }
         else if (input == "2")
         {
-            if (sendto(client_socket, (void *)get_nodes_list_msg.data(), get_nodes_list_msg.size(),
-                                MSG_WAITALL, (struct sockaddr *) &server_address, server_address_len) != 0)
+            if (send(client_socket, (void *)get_nodes_list_msg.data(), get_nodes_list_msg.size(),
+                                0) != 0)
             {
-                ERROR_PRINT_LN("Sendto returned error: ", strerror(errno), "(", errno, ")");
+                ERROR_PRINT_LN("Send returned error: ", strerror(errno), "(", errno, ")");
             }
         }
         else if (input == "3")
diff --git a/src/server/server.cpp b/src/server/server.cpp
index 582b347..1160196 100644
--- a/src/server/server.cpp
+++ b/src/server/server.cpp
@@ -10,7 +10,6 @@
 #include <cstring>
 #include <string>
 #include <unistd.h>
-#include <sqlite3.h>
 
 #include "server.h"
 
@@ -27,9 +26,13 @@ static const long seeder_server_select_wait_micro_seconds = 100000; // 100 milli
 static const int seeder_server_receive_buffer_size = 4096;
 
 static const std::string database_file_name("client_info.db");
-static const std::string create_table = "CREATE TABLE CLIENT_INFO("  \
-        "IPADDR INT PRIMARY KEY     NOT NULL," \
-        "PORT           INT     NOT NULL);";
+static const std::string create_table = "CREATE TABLE IF NOT EXISTS CLIENT_INFO("  \
+        "ID     INT      PRIMARY KEY NOT NULL," \
+        "IPADDR INT      NOT NULL," \
+        "PORT   INT      NOT NULL);";
+
+static const std::string insert_into_table = "INSERT INTO CLIENT_INFO (ID, IPADDR, " \
+        "PORT) VALUES (?, ?, ?);";
 /*
  * Local Types
  */
@@ -46,20 +49,11 @@ SeederServer::SeederServer()
     socket_thread = nullptr;
     reply_thread = nullptr;
     seeder_server_port = seeder_server_default_port;
-
-    database = nullptr;
+    client_info_list.clear();
 }
 
 SeederServer::~SeederServer()
 {
-    if (database)
-    {
-        sqlite3_close(database);
-        // Remove the below line to make the client info persistent across server
-        // reboots/shutdown.
-        unlink(database_file_name.c_str());
-    }
-
     if (reply_thread)
     {
         reply_thread->join();
@@ -97,38 +91,6 @@ status_e SeederServer::BlockSignals()
     return status_ok;
 }
 
-status_e SeederServer::InitDB()
-{
-    int ret;
-    char *error_msg;
-
-    ret = sqlite3_open(database_file_name.c_str(), &database);
-
-    if(ret != SQLITE_OK)
-    {
-        ERROR_PRINT_LN("Can't open database: ", sqlite3_errmsg(database));
-        return status_error;
-    }
-    else
-    {
-        DEBUG_PRINT_LN("Opened database successfully");
-    }
-
-    ret = sqlite3_exec(database, create_table.c_str(), nullptr, 0, &error_msg);
-
-    if (ret != SQLITE_OK)
-    {
-        ERROR_PRINT_LN("SQL error: ", error_msg);
-        sqlite3_free(error_msg);
-    }
-    else
-    {
-        DEBUG_PRINT_LN("Table created successfully");
-    }
-
-    return status_ok;
-}
-
 void SeederServer::ReceiveSignal()
 {
     int signal;
@@ -166,7 +128,7 @@ status_e SeederServer::SetupSocket()
 {
     DEBUG_PRINT_LN("");
 
-    if ((seeder_server_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == 0)
+    if ((seeder_server_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0)
     {
         ERROR_PRINT_LN("Seeder server socket creation failed");
         return status_error;
@@ -180,16 +142,22 @@ status_e SeederServer::SetupSocket()
         return status_error;
     }
 
-    address.sin_family = AF_INET;
-    address.sin_addr.s_addr = INADDR_ANY;
-    address.sin_port = htons(seeder_server_port);
+    seeder_server_address.sin_family = AF_INET;
+    seeder_server_address.sin_addr.s_addr = INADDR_ANY;
+    seeder_server_address.sin_port = htons(seeder_server_port);
 
-    if (bind(seeder_server_socket, reinterpret_cast<sockaddr *>(&address), sizeof(address)) != 0)
+    if (bind(seeder_server_socket, reinterpret_cast<sockaddr *>(&seeder_server_address), sizeof(seeder_server_address)) != 0)
     {
         ERROR_PRINT_LN("Bind failed for server socket");
         return status_error;
     }
 
+    if (listen(seeder_server_socket, SOMAXCONN) != 0)
+    {
+        ERROR_PRINT_LN("Listen failed for server socket");
+        return status_error;
+    }
+
     socket_thread.reset(new std::thread(&SeederServer::SocketFunction, this));
 
     DEBUG_PRINT_LN("completed");
@@ -203,43 +171,67 @@ status_e SeederServer::SocketFunction()
     int nfds;
     int result;
     char buffer[seeder_server_receive_buffer_size];
-    struct sockaddr_in client_addr;
-    socklen_t client_addr_len;
     size_t num_bytes_received;
 
     DEBUG_PRINT_LN("");
 
-    nfds = 0;
-    client_addr_len = sizeof(client_addr);
+
     while(true)
     {
-        memset(&client_addr, 0, sizeof(client_addr));
         FD_ZERO(&readfds);
         FD_SET(seeder_server_socket, &readfds);
-
-        nfds = seeder_server_socket + 1;
-
+        nfds = seeder_server_socket;
         tv.tv_sec = seeder_server_select_wait_seconds;
         tv.tv_usec = seeder_server_select_wait_micro_seconds;
+        {
+            std::lock_guard<std::mutex> lock(client_info_list_mutex);
+            for (auto client_info : client_info_list)
+            {
+                FD_SET(client_info.client_socket, &readfds);
+                if (nfds < client_info.client_socket)
+                {
+                    nfds = client_info.client_socket;
+                }
+            }
+        }
 
-        result = select(nfds, &readfds, (fd_set *)nullptr, (fd_set *)nullptr, &tv);
+        result = select(nfds + 1, &readfds, (fd_set *)nullptr, (fd_set *)nullptr, &tv);
 
         if (result > 0)
         {
             if (FD_ISSET(seeder_server_socket, &readfds))
             {
-                num_bytes_received = recvfrom(seeder_server_socket, (char *)buffer, seeder_server_receive_buffer_size,
-                                               MSG_WAITALL, (struct sockaddr *) &client_addr,
-                                               &client_addr_len);
-
-                buffer[num_bytes_received] = '\0';
-//                INFO_PRINT_LN("", buffer, client_addr.sin_port);
-
-                // Emplace to queue (instead of push) and notify
+                struct sockaddr_in client_address;
+                size_t client_address_len;
+                int new_socket;
+                if ((new_socket = accept(seeder_server_socket, reinterpret_cast<sockaddr*>(&client_address),
+                                                   (socklen_t*)&client_address_len)) > 0)
+                {
+                    std::lock_guard<std::mutex> lock(client_info_list_mutex);
+                    client_info_list.emplace_back(new_socket, client_address, client_address_len);
+                }
+            }
+            {
+                std::lock_guard<std::mutex> lock(client_info_list_mutex);
+                for (auto client_info : client_info_list)
                 {
-                    std::lock_guard<std::mutex> lock(queue_signal_mutex);
-                    receive_socket_queue.push(receive_socket_data(buffer, num_bytes_received, client_addr, client_addr_len));
-                    queue_signal_cv.notify_all();
+                    if (FD_ISSET(client_info.client_socket, &readfds))
+                    {
+                        num_bytes_received = recv(client_info.client_socket,
+                                (char *)buffer, seeder_server_receive_buffer_size,
+                                0);
+
+                        buffer[num_bytes_received] = '\0';
+//                        INFO_PRINT_LN("", buffer, client_info.client_address.sin_port);
+
+                        // Emplace to queue (instead of push) and notify
+                        {
+                            std::lock_guard<std::mutex> lock(queue_signal_mutex);
+                            receive_socket_queue.emplace(buffer, num_bytes_received,
+                                    client_info.client_address, client_info.client_addr_len);
+                            queue_signal_cv.notify_all();
+                        }
+                    }
                 }
             }
         }
@@ -263,31 +255,8 @@ status_e SeederServer::SocketFunction()
     return status_ok;
 }
 
-status_e SeederServer::CheckAndAddToTable(struct sockaddr_in client_address,
-        size_t client_addr_len)
+status_e SeederServer::PrepareNodesList()
 {
-    int ret;
-    char *error_msg;
-    // For now just add to table, later need to check and add
-    std::string sql("INSERT INTO CLIENT_INFO VALUES(");
-    std::string sql1(std::to_string(client_address.sin_addr.s_addr));
-    std::string command(", ");
-    std::string sql2(std::to_string(client_address.sin_port));
-    std::string sql3(");");
-
-    std::string complete_command = sql + sql1 + command + sql2 + sql3;
-
-    ret = sqlite3_exec(database, complete_command.c_str(), NULL, 0, &error_msg);
-    if (ret != SQLITE_OK)
-    {
-        ERROR_PRINT_LN("Error Insert");
-        sqlite3_free(error_msg);
-    }
-    else
-    {
-        INFO_PRINT_LN("Records created Successfully!");
-    }
-
     return status_ok;
 }
 
@@ -319,12 +288,12 @@ status_e SeederServer::ProcessReply()
         INFO_PRINT_LN("", rsd.buffer, " ", rsd.client_address.sin_port);
         if (rsd.buffer == hello_msg)
         {
-            // Client introduction, add to database if not present previously
-            CheckAndAddToTable(rsd.client_address, rsd.client_addr_len);
+            // Already added to list when accepting the connection from client.
         }
         else if (rsd.buffer == get_nodes_list_msg)
         {
             // Client asking for nodes list, prepare and send.
+            PrepareNodesList();
         }
     }
 
@@ -371,12 +340,6 @@ void server()
         return;
     }
 
-    if(seeder_server.InitDB() != status_ok)
-    {
-        ERROR_PRINT_LN("Init Database failed");
-        return;
-    }
-
     if(seeder_server.StartThreads() != status_ok)
     {
         ERROR_PRINT_LN("Start Threads failed");
diff --git a/src/server/server.h b/src/server/server.h
index b89dcbf..3c90159 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -11,6 +11,8 @@
 #include <memory>
 #include <atomic>
 #include <queue>
+#include <list>
+#include <cstring>
 
 #include <signal.h>
 #include <sys/socket.h>
@@ -44,6 +46,21 @@ struct receive_socket_data
     size_t client_addr_len;
 } ;
 
+struct client_info
+{
+    client_info() {}
+
+    client_info(int arg_client_socket, struct sockaddr_in arg_client_address, size_t arg_client_addr_len)
+                    : client_socket(arg_client_socket), client_addr_len(arg_client_addr_len)
+    {
+        memcpy(&client_address, &arg_client_address, arg_client_addr_len);
+    }
+
+    int client_socket;
+    struct sockaddr_in client_address;
+    size_t client_addr_len;
+};
+
 class SeederServer
 {
 public:
@@ -51,11 +68,10 @@ public:
     ~SeederServer();
 
     status_e BlockSignals();
-    status_e InitDB();
     void ReceiveSignal();
     status_e SetupSocket();
     status_e SocketFunction();
-    status_e CheckAndAddToTable(struct sockaddr_in client_address, size_t client_addr_len);
+    status_e PrepareNodesList();
     status_e ProcessReply();
     status_e StartThreads();
 
@@ -68,7 +84,7 @@ private:
     std::atomic<bool> shutdown_requested;
 
     int seeder_server_socket;
-    struct sockaddr_in address;
+    struct sockaddr_in seeder_server_address;
     int seeder_server_port;
 
     std::mutex queue_signal_mutex;
@@ -76,7 +92,8 @@ private:
     std::condition_variable queue_signal_cv;
     bool signal_received;
 
-    sqlite3 *database;
+    std::mutex client_info_list_mutex;
+    std::list<client_info> client_info_list;
 };
 
 #endif // SERVER_H_
